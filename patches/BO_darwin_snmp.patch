diff -Naur ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/host/hr_storage.c ./agent/mibgroup/host/hr_storage.c
--- ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/host/hr_storage.c	2004-12-20 09:30:42.000000000 -0800
+++ ./agent/mibgroup/host/hr_storage.c	2004-12-20 10:28:32.000000000 -0800
@@ -79,12 +79,16 @@
 #if defined(CTL_HW) && defined(HW_PAGESIZE)
 #define USE_SYSCTL
 #endif
-#if defined(CTL_VM) && defined(VM_METER)
+#if defined(CTL_VM) && defined(VM_METER) && !defined(darwin8)
 #define USE_SYSCTL_VM
 #endif
 #endif
 #endif                          /* ifndef dynix */
 
+#if defined(darwin8) /* This is to use host_statistics on OS X */
+#include <mach/mach.h>
+#endif
+
 #include "host_res.h"
 #include "hr_storage.h"
 #include "hr_filesys.h"
@@ -189,6 +193,10 @@
 
 #endif
 
+#if defined(darwin8) /* This is to use host_statistics() on OS X */
+mach_port_t myHost;
+#endif
+
 static int      physmem, pagesize;
 static void parse_storage_config(const char *, char *);
 
@@ -300,6 +308,10 @@
     auto_nlist(MBSTAT_SYMBOL, 0, 0);
 #endif
 
+#if defined(darwin8)
+    myHost = mach_host_self();
+#endif
+
     REGISTER_MIB("host/hr_storage", hrstore_variables, variable4,
                  hrstore_variables_oid);
 
@@ -314,9 +326,8 @@
 {
     char *val;
     int ival;
-    char *st;
 
-    val = strtok_r(cptr, " \t", &st);
+    val = strtok(cptr, " \t");
     if (!val) {
         config_perror("Missing FLAG parameter in storageUseNFS");
         return;
@@ -469,6 +480,9 @@
     int             swap_total, swap_used;
 #elif defined(hpux10) || defined(hpux11)
     struct pst_dynamic pst_buf;
+#elif defined(darwin8)
+    vm_statistics_data_t vm_stat;
+    int count = HOST_VM_INFO_COUNT;
 #elif defined(TOTAL_MEMORY_SYMBOL) || defined(USE_SYSCTL_VM)
     struct vmtotal  memory_totals;
 #endif
@@ -489,7 +503,7 @@
             return NULL;
     } else {
 
-really_try_next:
+try_next:
 	store_idx = header_hrstoreEntry(vp, name, length, exact, var_len,
 					write_method);
 	if (store_idx == MATCH_FAILED)
@@ -514,6 +528,8 @@
                     mib[1] = VM_METER;
                     sysctl(mib, 2, &memory_totals, &len, NULL, 0);
                 }
+#elif defined(darwin8)
+		host_statistics(myHost,HOST_VM_INFO,&vm_stat,&count);
 #elif defined(hpux10) || defined(hpux11)
                 pstat_getdynamic(&pst_buf, sizeof(struct pst_dynamic), 1, 0);
 #elif defined(TOTAL_MEMORY_SYMBOL)
@@ -607,8 +623,6 @@
             case HRS_TYPE_MBUF:
 #ifdef MSIZE
                 long_return = MSIZE;
-#elif defined(linux)
-                long_return = 1024;
 #else
                 long_return = 256;
 #endif
@@ -627,7 +641,6 @@
         else
             switch (store_idx) {
 #if defined(linux)
-            case HRS_TYPE_MBUF:
             case HRS_TYPE_MEM:
             case HRS_TYPE_SWAP:
                 long_return = linux_mem(store_idx, HRSTORE_SIZE);
@@ -647,7 +660,19 @@
             case HRS_TYPE_SWAP:
                 long_return = pst_buf.psd_vm;
                 break;
-#elif defined(TOTAL_MEMORY_SYMBOL) || defined(USE_SYSCTL_VM)
+#elif defined(darwin8)
+            case HRS_TYPE_MEM:
+                long_return = physmem;
+                break;
+            case HRS_TYPE_SWAP:
+                long_return = -1;
+	        break;
+#if defined(MBSTAT_SYMBOL)
+	    case HRS_TYPE_MBUF:
+                long_return = mbstat.m_mbufs;
+                break; 
+#endif /* defined(darwin8) */
+#elif defined(TOTAL_MEMORY_SYMBOL) || defined(USE_SYSCTL_VM) 
             case HRS_TYPE_MEM:
                 long_return = memory_totals.t_rm;
                 break;
@@ -695,7 +720,6 @@
         else
             switch (store_idx) {
 #if defined(linux)
-            case HRS_TYPE_MBUF:
             case HRS_TYPE_MEM:
             case HRS_TYPE_SWAP:
                 long_return = linux_mem(store_idx, HRSTORE_USED);
@@ -716,6 +740,13 @@
             case HRS_TYPE_SWAP:
                 long_return = pst_buf.psd_avm;
                 break;
+#elif defined(darwin8)
+	    case HRS_TYPE_MEM:
+		long_return = vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count;
+		break;
+	    case HRS_TYPE_SWAP:
+		long_return = -1;
+		break;
 #elif defined(TOTAL_MEMORY_SYMBOL) || defined(USE_SYSCTL_VM)
             case HRS_TYPE_MEM:
                 long_return = memory_totals.t_arm;
@@ -731,7 +762,7 @@
                 long_return = (mbpool.pr_nget - mbpool.pr_nput)
                     * mbpool.pr_size + (mclpool.pr_nget - mclpool.pr_nput)
                     * mclpool.pr_size;
-#elif defined(MBSTAT_SYMBOL) && defined(STRUCT_MBSTAT_HAS_M_CLUSTERS)
+#elif defined(MBSTAT_SYMBOL)
                 long_return = mbstat.m_clusters - mbstat.m_clfree;      /* unlikely, but... */
 #elif defined(NO_DUMMY_VALUES)
                 goto try_next;
@@ -782,12 +813,6 @@
                     vp->magic));
     }
     return NULL;
-
-  try_next:
-    if (!exact)
-        goto really_try_next;
-
-    return NULL;
 }
 
 
@@ -803,7 +828,7 @@
 void
 Init_HR_Store(void)
 {
-#if !defined(solaris2) && !defined(hpux10) && !defined(hpux11)
+#if !defined(solaris2) && !defined(hpux10) && !defined(hpux11) && !defined(linux)
     HRS_index = 0;
 #else
     HRS_index = HRS_TYPE_MBUF;
@@ -847,32 +872,23 @@
 {
     FILE           *fp;
     char            buf[1024];
-    int             size = -1, free = -1, buffers = -1;
+    int             size = -1, free = -1;
 
     if ((fp = fopen("/proc/meminfo", "r")) == NULL)
         return -1;
 
     while (fgets(buf, sizeof(buf), fp) != NULL) {
-       if ((!strncmp(buf, "MemTotal:", 9) && (mem_type == HRS_TYPE_MEM || mem_type == HRS_TYPE_MBUF)) ||
+       if ((!strncmp(buf, "MemTotal:", 9) && mem_type == HRS_TYPE_MEM) ||
             (!strncmp(buf, "SwapTotal:", 10) && mem_type == HRS_TYPE_SWAP))
             sscanf(buf, "%*s %d", &size);
 
        if ((!strncmp(buf, "MemFree:", 8) && mem_type == HRS_TYPE_MEM) ||
             (!strncmp(buf, "SwapFree:", 9) && mem_type == HRS_TYPE_SWAP))
             sscanf(buf, "%*s %d", &free);
-
-       if ((!strncmp(buf, "Buffers:", 8) && mem_type == HRS_TYPE_MBUF))
-		sscanf(buf, "%*s %d", &buffers);
     }
 
     fclose(fp);
-
-    switch (mem_type) {
-        case HRS_TYPE_MBUF:
-            return (size_or_used == HRSTORE_SIZE ? size : buffers);
-        default:
-            return (size_or_used == HRSTORE_SIZE ? size : (size - free));
-    } /* switch */
+    return (size_or_used == HRSTORE_SIZE ? size : (size - free));
 
 }
 #endif
diff -Naur ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd-snmp/memory_darwin7.c ./agent/mibgroup/ucd-snmp/memory_darwin7.c
--- ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd-snmp/memory_darwin7.c	1969-12-31 16:00:00.000000000 -0800
+++ ./agent/mibgroup/ucd-snmp/memory_darwin7.c	2004-12-20 10:54:01.000000000 -0800
@@ -0,0 +1,394 @@
+/*
+ * memory_darwin7.c
+ */
+
+#include <net-snmp/net-snmp-config.h>
+
+
+/*
+ * Ripped from /usr/scr/usr.bin/vmstat/vmstat.c (covering all bases) 
+ */
+#include <sys/param.h>
+#include <sys/time.h>
+#include <sys/proc.h>
+#include <sys/dkstat.h>
+#include <sys/buf.h>
+#include <sys/uio.h>
+#include <sys/malloc.h>
+#include <sys/signal.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/sysctl.h>
+#include <sys/vmmeter.h>
+#include <sys/stat.h>
+
+#include <time.h>
+#include <nlist.h>
+#include <kvm.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <paths.h>
+#include <limits.h>
+#include <mach/mach.h>
+#include <dirent.h>
+
+#if HAVE_DMALLOC_H
+#include <dmalloc.h>
+#endif
+
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/auto_nlist.h>
+
+#include "util_funcs.h"
+#include "memory.h"
+#include "memory_darwin7.h"
+
+/*
+ *  * Swap info 
+ *   */
+/*off_t		swapTotal;
+off_t		swapUsed;
+off_t		swapFree;
+*/
+
+/*
+ * Default swap warning limit (kb) 
+ */
+#define DEFAULTMINIMUMSWAP 16000
+
+/*
+ * Swap warning limit 
+ */
+long            minimumswap;
+
+static FindVarMethod var_extensible_mem;
+
+void
+init_memory_darwin7(void)
+{
+
+    struct variable2 extensible_mem_variables[] = {
+        {MIBINDEX, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MIBINDEX}},
+        {ERRORNAME, ASN_OCTET_STR, RONLY, var_extensible_mem, 1, {ERRORNAME}},
+        {MEMTOTALSWAP, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMTOTALSWAP}},
+        {MEMAVAILSWAP, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMAVAILSWAP}},
+        {MEMTOTALREAL, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMTOTALREAL}},
+        {MEMAVAILREAL, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMAVAILREAL}},
+        {MEMTOTALSWAPTXT, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMTOTALSWAPTXT}},
+        {MEMUSEDSWAPTXT, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMUSEDSWAPTXT}},
+        {MEMTOTALREALTXT, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMTOTALREALTXT}},
+        {MEMUSEDREALTXT, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMUSEDREALTXT}},
+        {MEMTOTALFREE, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMTOTALFREE}},
+        {MEMSWAPMINIMUM, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMSWAPMINIMUM}},
+        {MEMSHARED, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMSHARED}},
+        {MEMBUFFER, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMBUFFER}},
+        {MEMCACHED, ASN_INTEGER, RONLY, var_extensible_mem, 1, {MEMCACHED}},
+        {ERRORFLAG, ASN_INTEGER, RONLY, var_extensible_mem, 1, {ERRORFLAG}},
+        {ERRORMSG, ASN_OCTET_STR, RONLY, var_extensible_mem, 1, {ERRORMSG}}
+    };
+
+    /*
+     * Define the OID pointer to the top of the mib tree that we're
+     * registering underneath 
+     */
+    oid             mem_variables_oid[] = { UCDAVIS_MIB, MEMMIBNUM };
+
+    /*
+     * register ourselves with the agent to handle our mib tree 
+     */
+    REGISTER_MIB("ucd-snmp/memory", extensible_mem_variables, variable2,
+                 mem_variables_oid);
+
+    snmpd_register_config_handler("swap", memory_parse_config,
+                                  memory_free_config, "min-avail");
+}
+
+
+void
+memory_parse_config(const char *token, char *cptr)
+{
+    minimumswap = atoi(cptr);
+}
+
+void
+memory_free_config(void)
+{
+    minimumswap = DEFAULTMINIMUMSWAP;
+}
+
+off_t 
+swapsize(void)
+{
+    int		pagesize;
+    int		i, n;
+    DIR		*dirp;
+    struct dirent *dp;
+    struct stat	buf;
+    char	errmsg[1024];
+    char	full_name[1024];
+    off_t	swapSize;
+
+    /* we set the size to -1 if we're not supported */
+    swapSize = -1;
+
+#if defined(SWAPFILE_DIR) && defined(SWAPFILE_PREFIX)
+    dirp = opendir((const char *) SWAPFILE_DIR);
+    while((dp = readdir(dirp)) != NULL) {
+	/* if the file starts with the same as SWAPFILE_PREFIX
+	 * we want to stat the file to get it's size
+	 */
+	if(strspn(dp->d_name,(char *) SWAPFILE_PREFIX) == strlen((char *) SWAPFILE_PREFIX)) {
+		sprintf(full_name,"%s/%s",SWAPFILE_DIR,dp->d_name);
+		/* we need to stat each swapfile to get it's size */
+		if(stat(full_name,&buf) != 0) {
+        		sprintf(errmsg, "swapsize: can't stat file %s",full_name);
+	    		snmp_log_perror(errmsg);
+		} else {
+			/* total swap allocated is the size of
+			 * all the swapfile's that exist in
+			 * the SWAPFILE_DIR dir
+			 */ 
+			swapSize += buf.st_size;  
+		}
+	}
+
+    }
+    closedir(dirp);
+#endif
+
+    return swapSize;
+
+}
+
+
+/*
+ * var_extensible_mem(...
+ * Arguments:
+ * vp     IN      - pointer to variable entry that points here
+ * name    IN/OUT  - IN/name requested, OUT/name found
+ * length  IN/OUT  - length of IN/OUT oid's 
+ * exact   IN      - TRUE if an exact match was requested
+ * var_len OUT     - length of variable or 0 if function returned
+ * write_method
+ * 
+ */
+
+static unsigned char *
+var_extensible_mem(struct variable *vp,
+                   oid * name,
+                   size_t * length,
+                   int exact,
+                   size_t * var_len, WriteMethod ** write_method)
+{
+    static long     long_ret;
+    static char     errmsg[1024];
+    /* the getting used swap routine takes awhile, so we
+     * do not want to run it often, so we use a cache to
+     * keep from updating it too often
+     */
+    static time_t   prev_time;
+    time_t          cur_time = time((time_t *)NULL);
+
+    int             mib[2];
+
+    u_long          phys_mem;
+    size_t          phys_mem_size = sizeof(phys_mem);
+
+    int		    pagesize;
+    size_t          pagesize_size = sizeof(pagesize);
+
+    u_long	    pages_used;
+
+    off_t	    swapFree;
+    static off_t	    swapUsed;
+    off_t	    swapSize;
+   
+    /* for host_statistics() */
+    vm_statistics_data_t vm_stat;
+    int count = HOST_VM_INFO_COUNT;
+
+    if (header_generic(vp, name, length, exact, var_len, write_method))
+        return (NULL);
+
+    mib[0] = CTL_HW;
+    mib[1] = HW_PHYSMEM;
+    
+    /*
+     * Physical memory 
+     */
+    if(sysctl(mib, 2, &phys_mem, &phys_mem_size, NULL, 0) == -1)
+	    snmp_log_perror("sysctl: phys_mem");
+
+    /*
+     * Pagesize
+     */
+    mib[1] = HW_PAGESIZE;
+    if(sysctl(mib, 2, &pagesize, &pagesize_size, NULL, 0) == -1)
+	    snmp_log_perror("sysctl: pagesize");
+    /*
+     * used memory
+     */
+    host_statistics(mach_host_self(),HOST_VM_INFO,&vm_stat,&count);
+    pages_used = vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count;
+    /*
+     * Page-to-kb macro 
+     */
+#define ptok(p) ((p) * (pagesize >> 10))
+
+    /*
+     * swap info
+     */
+
+    swapSize = swapsize();
+    /* if it's been less then 30 seconds since the
+    * last run, don't call the pages_swapped() 
+    * routine yet */
+    if(cur_time > prev_time + 30) {
+        swapUsed = (off_t) pages_swapped();
+        prev_time = time((time_t *)NULL);
+    }
+    swapFree = swapSize - (swapUsed * pagesize);
+
+    long_ret = 0;               /* set to 0 as default */
+
+    switch (vp->magic) {
+    case MIBINDEX:
+        long_ret = 0;
+        return ((u_char *) (&long_ret));
+    case ERRORNAME:            /* dummy name */
+        sprintf(errmsg, "swap");
+        *var_len = strlen(errmsg);
+        return ((u_char *) (errmsg));
+    case MEMTOTALSWAP:
+        long_ret = swapSize >> 10;
+        return ((u_char *) (&long_ret));
+    case MEMAVAILSWAP:         /* FREE swap memory */
+	    long_ret = swapFree >> 10;
+        return ((u_char *) (&long_ret));
+    case MEMTOTALREAL:
+        long_ret = phys_mem >> 10;
+        return ((u_char *) (&long_ret));
+    case MEMAVAILREAL:         /* FREE real memory */
+        long_ret = (phys_mem >> 10) - (ptok(pages_used));
+        return ((u_char *) (&long_ret));
+    case MEMSWAPMINIMUM:
+	long_ret = minimumswap;
+	return ((u_char *) (&long_ret));
+        /*
+         * these are not implemented 
+         */
+    case MEMTOTALSWAPTXT:
+    case MEMUSEDSWAPTXT:
+    case MEMTOTALREALTXT:
+    case MEMUSEDREALTXT:
+    case MEMTOTALFREE:
+    case MEMSHARED:
+    case MEMBUFFER:
+    case MEMCACHED:
+#if NO_DUMMY_VALUES
+        return NULL;
+#endif
+        long_ret = -1;
+        return ((u_char *) (&long_ret));
+
+    case ERRORFLAG:
+        long_ret = (swapFree > minimumswap) ? 0 : 1;
+        return ((u_char *) (&long_ret));
+    case ERRORMSG:
+        if (swapFree < minimumswap)
+            sprintf(errmsg, "Running out of swap space (%qd)", swapFree);
+        else
+            errmsg[0] = 0;
+        *var_len = strlen(errmsg);
+        return ((u_char *) (errmsg));
+    }
+    return NULL;
+}
+
+
+/* get the number of pages that are swapped out */
+/* we think this is correct and are valid values */
+/* but not sure. time will tell if it's correct */
+/* Note: this routine is _expensive_!!! we run this */
+/* as little as possible by caching it's return so */
+/* it's not run on every poll */
+/* Apple, please give us a better way! :) */
+int pages_swapped(void) {
+     boolean_t       retval;
+     kern_return_t   error;
+     processor_set_t *psets, pset;
+     task_t          *tasks;
+     unsigned        i, j, pcnt, tcnt;
+     int             pid;
+     mach_msg_type_number_t  count;
+     vm_address_t        address;
+     mach_port_t     object_name;
+     vm_region_extended_info_data_t info;
+     vm_size_t       size;
+     mach_port_t mach_port;
+     int   swapped_pages;
+     int   swapped_pages_total = 0;
+     char    errmsg[1024];
+
+
+     mach_port = mach_host_self();
+     error = host_processor_sets(mach_port, &psets, &pcnt);
+     if (error != KERN_SUCCESS) {
+        sprintf(errmsg, "Error in host_processor_sets(): %s\n", mach_error_string(error));
+        snmp_log_perror(errmsg);
+        return(0);
+     }
+
+     for (i = 0; i < pcnt; i++) {
+        error = host_processor_set_priv(mach_port, psets[i], &pset);
+        if (error != KERN_SUCCESS) {
+            sprintf(errmsg,"Error in host_processor_set_priv(): %s\n", mach_error_string(error));
+            snmp_log_perror(errmsg);
+            return(0);
+        }
+
+        error = processor_set_tasks(pset, &tasks, &tcnt);
+        if (error != KERN_SUCCESS) {
+            sprintf(errmsg,"Error in processor_set_tasks(): %s\n", mach_error_string(error));
+            snmp_log_perror(errmsg);
+            return(0);
+        }
+
+        for (j = 0; j < tcnt; j++) {
+            error = pid_for_task(tasks[j], &pid);
+            if (error != KERN_SUCCESS) {
+                /* Not a process, or the process is gone. */
+                continue;
+            }
+
+            swapped_pages = 0;
+            for (address = 0;; address += size) {
+                /* Get memory region. */
+                count = VM_REGION_EXTENDED_INFO_COUNT; 
+                if (vm_region(tasks[j], &address, &size, VM_REGION_EXTENDED_INFO, (vm_region_extended_info_t)&info, &count, &object_name) != KERN_SUCCESS) {
+                    /* No more memory regions. */
+                    break;
+                }
+            
+                if(info.pages_swapped_out > 0) {
+                    swapped_pages += info.pages_swapped_out;
+                } 
+            }
+           
+            if(swapped_pages > 0) {
+                swapped_pages_total += swapped_pages; 
+            }
+
+            if (tasks[j] != mach_task_self()) {
+                mach_port_deallocate(mach_task_self(), tasks[j]);
+            }  
+        }
+    }
+
+    return(swapped_pages_total);
+}
diff -Naur ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd-snmp/memory_darwin7.h ./agent/mibgroup/ucd-snmp/memory_darwin7.h
--- ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd-snmp/memory_darwin7.h	1969-12-31 16:00:00.000000000 -0800
+++ ./agent/mibgroup/ucd-snmp/memory_darwin7.h	2004-12-20 10:28:32.000000000 -0800
@@ -0,0 +1,12 @@
+/*
+ *  memory quantity mib groups
+ *
+ */
+#ifndef _MIBGROUP_MEMORY_DARWIN7_H
+#define _MIBGROUP_MEMORY_DARWIN7_H
+
+#include "mibdefs.h"
+
+extern void     init_memory_darwin7(void);
+
+#endif                          /* _MIBGROUP_MEMORY_DARWIN7_H */
diff -Naur ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd-snmp/vmstat_darwin7.c ./agent/mibgroup/ucd-snmp/vmstat_darwin7.c
--- ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd-snmp/vmstat_darwin7.c	1969-12-31 16:00:00.000000000 -0800
+++ ./agent/mibgroup/ucd-snmp/vmstat_darwin7.c	2004-12-20 10:41:43.000000000 -0800
@@ -0,0 +1,317 @@
+/*
+ * vmstat_darwin7.c
+ */
+
+#include <net-snmp/net-snmp-config.h>
+
+/*
+ * Ripped from /usr/scr/usr.bin/vmstat/vmstat.c (covering all bases) 
+ */
+#include <sys/param.h>
+#include <sys/time.h>
+#include <sys/proc.h>
+#include <sys/dkstat.h>
+#include <sys/buf.h>
+#include <sys/uio.h>
+#include <sys/malloc.h>
+#include <sys/signal.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/sysctl.h>
+#include <sys/vmmeter.h>
+
+#if HAVE_SYS_VMPARAM_H
+#include <sys/vmparam.h>
+#else
+#include <vm/vm_param.h>
+#endif
+
+#include <time.h>
+#include <nlist.h>
+#include <kvm.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <paths.h>
+#include <limits.h>
+
+
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/auto_nlist.h>
+
+#include "util_funcs.h"
+#include "vmstat.h"
+#include "vmstat_darwin7.h"
+
+
+/*
+ * nlist symbols 
+ */
+#define CPTIME_SYMBOL   "cp_time"
+#define SUM_SYMBOL      "cnt"
+#define INTRCNT_SYMBOL  "intrcnt"
+#define EINTRCNT_SYMBOL "eintrcnt"
+#define BOOTTIME_SYMBOL "boottime"
+
+/*
+ * Number of interrupts 
+ */
+#define INT_COUNT       10
+
+/*
+ * CPU percentage 
+ */
+#define CPU_PRC         100
+
+FindVarMethod var_extensible_vmstat;
+
+void
+init_vmstat_darwin7(void)
+{
+
+    struct variable2 extensible_vmstat_variables[] = {
+        {MIBINDEX, ASN_INTEGER, RONLY, var_extensible_vmstat, 1,
+         {MIBINDEX}},
+        {ERRORNAME, ASN_OCTET_STR, RONLY, var_extensible_vmstat, 1,
+         {ERRORNAME}},
+        {SWAPIN, ASN_INTEGER, RONLY, var_extensible_vmstat, 1, {SWAPIN}},
+        {SWAPOUT, ASN_INTEGER, RONLY, var_extensible_vmstat, 1, {SWAPOUT}},
+        {IOSENT, ASN_INTEGER, RONLY, var_extensible_vmstat, 1, {IOSENT}},
+        {IORECEIVE, ASN_INTEGER, RONLY, var_extensible_vmstat, 1,
+         {IORECEIVE}},
+        {SYSINTERRUPTS, ASN_INTEGER, RONLY, var_extensible_vmstat, 1,
+         {SYSINTERRUPTS}},
+        {SYSCONTEXT, ASN_INTEGER, RONLY, var_extensible_vmstat, 1,
+         {SYSCONTEXT}},
+        {CPUUSER, ASN_INTEGER, RONLY, var_extensible_vmstat, 1, {CPUUSER}},
+        {CPUSYSTEM, ASN_INTEGER, RONLY, var_extensible_vmstat, 1,
+         {CPUSYSTEM}},
+        {CPUIDLE, ASN_INTEGER, RONLY, var_extensible_vmstat, 1, {CPUIDLE}},
+        {CPURAWUSER, ASN_COUNTER, RONLY, var_extensible_vmstat, 1,
+         {CPURAWUSER}},
+        {CPURAWNICE, ASN_COUNTER, RONLY, var_extensible_vmstat, 1,
+         {CPURAWNICE}},
+        {CPURAWSYSTEM, ASN_COUNTER, RONLY, var_extensible_vmstat, 1,
+         {CPURAWSYSTEM}},
+        {CPURAWIDLE, ASN_COUNTER, RONLY, var_extensible_vmstat, 1,
+         {CPURAWIDLE}},
+        {CPURAWKERNEL, ASN_COUNTER, RONLY, var_extensible_vmstat, 1,
+         {CPURAWKERNEL}},
+        {CPURAWINTR, ASN_COUNTER, RONLY, var_extensible_vmstat, 1,
+         {CPURAWINTR}},
+        {SYSRAWINTERRUPTS, ASN_COUNTER, RONLY, var_extensible_vmstat, 1,
+         {SYSRAWINTERRUPTS}},
+        {SYSRAWCONTEXT, ASN_COUNTER, RONLY, var_extensible_vmstat, 1,
+         {SYSRAWCONTEXT}},
+        /*
+         * Future use: 
+         */
+        /*
+         * {ERRORFLAG, ASN_INTEGER, RONLY, var_extensible_vmstat, 1, {ERRORFLAG }},
+         * {ERRORMSG, ASN_OCTET_STR, RONLY, var_extensible_vmstat, 1, {ERRORMSG }}
+         */
+    };
+
+    /*
+     * Define the OID pointer to the top of the mib tree that we're
+     * registering underneath 
+     */
+    oid             vmstat_variables_oid[] = { UCDAVIS_MIB, 11 };
+
+    /*
+     * register ourselves with the agent to handle our mib tree 
+     */
+    REGISTER_MIB("ucd-snmp/vmstat", extensible_vmstat_variables, variable2,
+                 vmstat_variables_oid);
+
+}
+
+
+long
+getuptime(void)
+{
+    static time_t   now, boottime;
+    time_t          uptime;
+
+    if (boottime == 0)
+        auto_nlist(BOOTTIME_SYMBOL, (char *) &boottime, sizeof(boottime));
+
+    time(&now);
+    uptime = now - boottime;
+
+    return (uptime);
+}
+
+unsigned char  *
+var_extensible_vmstat(struct variable *vp,
+                      oid * name,
+                      size_t * length,
+                      int exact,
+                      size_t * var_len, WriteMethod ** write_method)
+{
+
+    int             loop;
+
+    time_t          time_new = getuptime();
+    static time_t   time_old;
+    static time_t   time_diff;
+
+/*    static long     cpu_old[CPUSTATES];
+    static long     cpu_new[CPUSTATES];
+    static long     cpu_diff[CPUSTATES]; */
+    static long     cpu_total;
+    long            cpu_sum;
+    double          cpu_prc;
+
+    static struct vmmeter mem_old, mem_new;
+
+    static long     long_ret;
+    static char     errmsg[300];
+
+    long_ret = 0;               /* set to 0 as default */
+
+    if (header_generic(vp, name, length, exact, var_len, write_method))
+        return (NULL);
+
+    /*
+     * Update structures (only if time has passed)
+     * we only update every 30 seconds so that we don't
+     * get strange results, especially with cpu information
+     */    
+    if (time_new > time_old + 30) {
+        time_diff = time_new - time_old;
+        time_old = time_new;
+
+        /*
+         * CPU usage 
+         */
+/*        auto_nlist(CPTIME_SYMBOL, (char *) cpu_new, sizeof(cpu_new)); */
+
+        cpu_total = 0;
+
+/*        for (loop = 0; loop < CPUSTATES; loop++) {
+            cpu_diff[loop] = cpu_new[loop] - cpu_old[loop];
+            cpu_old[loop] = cpu_new[loop];
+            cpu_total += cpu_diff[loop];
+        }
+	*/
+
+        if (cpu_total == 0)
+            cpu_total = 1;
+
+        /*
+         * Memory info 
+         */
+        mem_old = mem_new;
+        auto_nlist(SUM_SYMBOL, (char *) &mem_new, sizeof(mem_new));
+    }
+
+    /*
+     * Rate macro 
+     */
+#define rate(x) (((x)+ time_diff/2) / time_diff)
+
+    /*
+     * Page-to-kb macro 
+     */
+#define ptok(p) ((p) * (mem_new.v_page_size >> 10))
+
+    switch (vp->magic) {
+    case MIBINDEX:
+        long_ret = 1;
+        return ((u_char *) (&long_ret));
+    case ERRORNAME:            /* dummy name */
+        sprintf(errmsg, "systemStats");
+        *var_len = strlen(errmsg);
+        return ((u_char *) (errmsg));
+    case SWAPIN:
+#if defined(openbsd2) || defined(darwin)
+        long_ret = ptok(mem_new.v_swpin - mem_old.v_swpin);
+#else
+        long_ret = ptok(mem_new.v_swappgsin - mem_old.v_swappgsin +
+                        mem_new.v_vnodepgsin - mem_old.v_vnodepgsin);
+#endif
+        long_ret = rate(long_ret);
+        return ((u_char *) (&long_ret));
+    case SWAPOUT:
+#if defined(openbsd2) || defined(darwin)
+        long_ret = ptok(mem_new.v_swpout - mem_old.v_swpout);
+#else
+        long_ret = ptok(mem_new.v_swappgsout - mem_old.v_swappgsout +
+                        mem_new.v_vnodepgsout - mem_old.v_vnodepgsout);
+#endif
+        long_ret = rate(long_ret);
+        return ((u_char *) (&long_ret));
+    case IOSENT:
+#if NO_DUMMY_VALUES
+        return NULL;
+#endif
+        long_ret = -1;
+        return ((u_char *) (&long_ret));
+    case IORECEIVE:
+#if NO_DUMMY_VALUES
+        return NULL;
+#endif
+        long_ret = -1;
+        return ((u_char *) (&long_ret));
+    case SYSINTERRUPTS:
+        long_ret = rate(mem_new.v_intr - mem_old.v_intr);
+        return ((u_char *) (&long_ret));
+    case SYSCONTEXT:
+        long_ret = rate(mem_new.v_swtch - mem_old.v_swtch);
+        return ((u_char *) (&long_ret));
+    case CPUUSER:
+/*        cpu_sum = cpu_diff[CP_USER] + cpu_diff[CP_NICE];
+        cpu_prc = (float) cpu_sum / (float) cpu_total;
+        long_ret = cpu_prc * CPU_PRC; */
+        return ((u_char *) (&long_ret));
+    case CPUSYSTEM:
+/*        cpu_sum = cpu_diff[CP_SYS] + cpu_diff[CP_INTR];
+        cpu_prc = (float) cpu_sum / (float) cpu_total;
+        long_ret = cpu_prc * CPU_PRC; */
+        return ((u_char *) (&long_ret));
+    case CPUIDLE:
+/*        cpu_sum = cpu_diff[CP_IDLE];
+        cpu_prc = (float) cpu_sum / (float) cpu_total;
+        long_ret = cpu_prc * CPU_PRC; */
+        return ((u_char *) (&long_ret));
+    case CPURAWUSER:
+/*        long_ret = cpu_new[CP_USER]; */
+        return ((u_char *) (&long_ret));
+    case CPURAWNICE:
+/*        long_ret = cpu_new[CP_NICE]; */
+        return ((u_char *) (&long_ret));
+    case CPURAWSYSTEM:
+/*        long_ret = cpu_new[CP_SYS] + cpu_new[CP_INTR]; */
+        return ((u_char *) (&long_ret));
+    case CPURAWIDLE:
+/*        long_ret = cpu_new[CP_IDLE]; */
+        return ((u_char *) (&long_ret));
+    case CPURAWKERNEL:
+/*        long_ret = cpu_new[CP_SYS]; */
+        return ((u_char *) (&long_ret));
+    case CPURAWINTR:
+/*        long_ret = cpu_new[CP_INTR]; */
+        return ((u_char *) (&long_ret));
+    case SYSRAWINTERRUPTS:
+        long_ret = mem_new.v_intr;
+        return ((u_char *) (&long_ret));
+    case SYSRAWCONTEXT:
+        long_ret = mem_new.v_swtch;
+        return ((u_char *) (&long_ret));
+        /*
+         * reserved for future use 
+         */
+        /*
+         * case ERRORFLAG:
+         * return((u_char *) (&long_ret));
+         * case ERRORMSG:
+         * return((u_char *) (&long_ret));
+         */
+    }
+    return NULL;
+}
diff -Naur ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd-snmp/vmstat_darwin7.h ./agent/mibgroup/ucd-snmp/vmstat_darwin7.h
--- ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd-snmp/vmstat_darwin7.h	1969-12-31 16:00:00.000000000 -0800
+++ ./agent/mibgroup/ucd-snmp/vmstat_darwin7.h	2004-12-20 10:28:32.000000000 -0800
@@ -0,0 +1,12 @@
+/*
+ *  vmstat mib groups
+ *
+ */
+#ifndef _MIBGROUP_VMSTAT_DARWIN7_H
+#define _MIBGROUP_VMSTAT_DARWIN7_H
+
+#include "mibdefs.h"
+
+void            init_vmstat_darwin7(void);
+
+#endif                          /* _MIBGROUP_VMSTAT_DARWIN7_H */
diff -Naur ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd_snmp.h ./agent/mibgroup/ucd_snmp.h
--- ../net_snmp.roots.no_bo/net_snmp/net-snmp/agent/mibgroup/ucd_snmp.h	2004-08-17 02:06:38.000000000 -0700
+++ ./agent/mibgroup/ucd_snmp.h	2004-12-20 10:28:32.000000000 -0800
@@ -44,8 +44,8 @@
 config_arch_require(openbsd2, ucd-snmp/vmstat_netbsd1)
 config_arch_require(openbsd2, ucd-snmp/memory_netbsd1)
 config_arch_require(bsdi4, ucd-snmp/vmstat_bsdi4)
-config_arch_require(darwin1, ucd-snmp/vmstat_freebsd2)
-config_arch_require(darwin1, ucd-snmp/memory_freebsd2)
+config_arch_require(darwin8, ucd-snmp/memory_darwin7)
+config_arch_require(darwin8, ucd-snmp/vmstat_darwin7)
 config_arch_require(dynix, ucd-snmp/vmstat_dynix)
 config_arch_require(dynix, ucd-snmp/memory_dynix)
 config_add_mib(UCD-SNMP-MIB)
diff -Naur ../net_snmp.roots.no_bo/net_snmp/net-snmp/include/net-snmp/system/darwin7.h ./include/net-snmp/system/darwin7.h
--- ../net_snmp.roots.no_bo/net_snmp/net-snmp/include/net-snmp/system/darwin7.h	2004-07-20 22:29:52.000000000 -0700
+++ ./include/net-snmp/system/darwin7.h	2004-12-20 10:28:31.000000000 -0800
@@ -6,3 +6,9 @@
  * At least, as of 5.3.
  */
 #undef HAVE_FSTAB_H
+
+#define MBSTAT_SYMBOL "mbstat"
+#undef TOTAL_MEMORY_SYMBOL
+
+#define SWAPFILE_DIR "/private/var/vm"
+#define SWAPFILE_PREFIX "swapfile"
